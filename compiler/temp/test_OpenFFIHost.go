
// Code generated by OpenFFI. DO NOT EDIT.
// Host code for test.proto
package main

import "fmt"
import "os"
import "unsafe"
import "runtime"

/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I/home/tcs/src/github.com/OpenFFI/openffi-core/cmake-build-debug

#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <openffi_primitives.h>
#include <args_helpers.h>
void* xllr_handle = NULL;
void (*pcall)(const char*, uint32_t,
			 int64_t,
			 void**, uint64_t,
			 void**, uint64_t,
			 char**, uint64_t*
			 ) = NULL;

int64_t (*pload_function)(const char*, uint32_t,
						const char*, uint32_t,
						int64_t,
						char**, uint32_t*) = NULL;

#ifdef _WIN32 //// --- START WINDOWS ---
#include <Windows.h>
void get_last_error_string(DWORD err, char** out_err_str)
{
    DWORD bufLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
							     FORMAT_MESSAGE_IGNORE_INSERTS,
							     NULL,
							     err,
						         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						         (LPTSTR) out_err_str,
						         0,
						         NULL );

    // TODO: out_err_str should get cleaned up!
}

void* load_library(const char* name, char** out_err)
{
	void* handle = LoadLibraryA(name);
	if(!handle)
	{
		get_last_error_string(GetLastError(), out_err);
	}

	return handle;
}

const char* free_library(void* lib) // return error string. null if no error.
{
	if(!lib)
	{
		return NULL;
	}

	if(!FreeLibrary(lib))
	{
		char* out_err;
		get_last_error_string(GetLastError(), &out_err);
		return out_err;
	}

	return NULL;
}

void* load_symbol(void* handle, const char* name, char** out_err)
{
	void* res = GetProcAddress(handle, name);
	if(!res)
	{
		get_last_error_string(GetLastError(), out_err);
		return NULL;
	}

	return res;
}

#else // ------ START POSIX ----
#include <dlfcn.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = dlopen(name, RTLD_NOW);
	if(!handle)
	{
		*out_err = dlerror();
	}

	return handle;
}

const char* free_library(void* lib)
{
	if(dlclose(lib))
	{
		return dlerror();
	}

	return NULL;
}

const char* get_string_element(int index, openffi_string* str, openffi_size* sizes, openffi_size* out_size)
{
	const char* res = str[index];
	*out_size = sizes[index];
	return res;
}

void* load_symbol(void* handle, const char* name, char** out_err)
{
	void* res = dlsym(handle, name);
	if(!res)
	{
		*out_err = dlerror();
		return NULL;
	}

	return res;
}

#endif // ------- END POSIX -----

int64_t load_function(const char* runtime_plugin, uint32_t runtime_plugin_len,
						const char* function_path, uint32_t function_path_len,
						int64_t function_id_opt,
						char** out_err, uint32_t* out_err_len)
{
	return pload_function(runtime_plugin, runtime_plugin_len,
							function_path, function_path_len,
							function_id_opt,
							out_err, out_err_len);
}

void call(
		const char* runtime_plugin_name, uint32_t runtime_plugin_name_len,
		int64_t function_id,
		void** parameters, uint64_t parameters_length,
		void** return_values, uint64_t return_values_length,
		char** out_err, uint64_t* out_err_len
)
{
	pcall(runtime_plugin_name, runtime_plugin_name_len,
			function_id,
			parameters, parameters_length,
			return_values, return_values_length,
			out_err, out_err_len);
}

const char* load_xllr_api()
{
	char* out_err = NULL;
	pcall = load_symbol(xllr_handle, "call", &out_err);
	if(!pcall)
	{
		return out_err;
	}

	pload_function = load_symbol(xllr_handle, "load_function", &out_err);
	if(!pload_function)
	{
		return out_err;
	}

	return NULL;
}



*/
import "C"

func freeXLLR() error{
	errstr := C.free_library(C.xllr_handle)

	if errstr != nil{
		return fmt.Errorf("Failed to free XLLR: %v", C.GoString(errstr))
	}

	return nil
}

// TODO: make sure it is called only once!
func loadXLLR() error{

	if C.xllr_handle != nil && C.pcall != nil{
        return nil
    }

	openffiHome := os.Getenv("OPENFFI_HOME")
    if openffiHome == ""{
    	return fmt.Errorf("OPENFFI_HOME is not set")
	}

	var name *C.char
	if runtime.GOOS == "darwin" {
		name = C.CString(openffiHome+"/xllr.dylib")
	}else if runtime.GOOS == "windows"{
		name = C.CString(openffiHome+"\\xllr.dll")
	} else {
		name = C.CString(openffiHome+"/xllr.so")
	}

	defer C.free(unsafe.Pointer(name))

	var out_err *C.char
	if C.xllr_handle = C.load_library(name, &out_err)
	C.xllr_handle == nil{ // error has occurred
		return fmt.Errorf("Failed to load XLLR: %v", C.GoString(out_err))
	}

    if cerr := C.load_xllr_api(); cerr != nil{
        return fmt.Errorf("Failed to load call function: %v", C.GoString(cerr))
    }

	return nil
}




// Code to call foreign functions in module Service1 via XLLR

// Call to foreign F1
/*
F1 comment
param1 comment

*/

// p1 - = 3.141592
// p2 - = 2.71
// p3 - = -10
// p4 - = -20
// p5 - = -30
// p6 - = -40
// p7 - = 50
// p8 - = 60
// p9 - = 70
// p10 - = 80
// p11 - = true
// p12 - = This is an input
// p13 - = {element one, element two}
// p14 - = {2, 4, 6, 8, 10}
var F1_id int64 = -1
func F1( p1 float64, p2 float32, p3 int8, p4 int16, p5 int32, p6 int64, p7 uint8, p8 uint16, p9 uint32, p10 uint64, p11 bool, p12 string, p13 []string, p14 []uint8) (r1 []string, err error){

	// load XLLR
	err = loadXLLR()
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	// load function (no need to use a lock)
	runtime_plugin := "xllr.test"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(unsafe.Pointer(pruntime_plugin))

	if F1_id == -1{
		path := "module=/home/tcs/src/github.com/OpenFFI/lang-plugin-go/test,package=GoFuncs,function=F1"
		ppath := C.CString(path)
		defer C.free(unsafe.Pointer(ppath))

		var out_err *C.char
		var out_err_len C.uint32_t
		out_err_len = C.uint32_t(0)
		F1_id = int64(C.load_function(pruntime_plugin, C.uint(len(runtime_plugin)), ppath, C.uint(len(path)), C.int64_t(-1), &out_err, &out_err_len))
		
		if F1_id == -1{ // failed
			err = fmt.Errorf("Failed to load function %v: %v", "F1", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
			return
		}
	}

	paramsBufferLength := C.uint64_t(18)
	paramsBuffer := C.alloc_args_buffer(C.int(paramsBufferLength))

	returnValuesBufferLength := C.uint64_t(3)
	returnValuesBuffer := C.alloc_args_buffer(C.int(returnValuesBufferLength))
	
	// convert parameters to C
	
	
	in_p1 := C.openffi_float64(p1); C.set_arg(paramsBuffer, 0, unsafe.Pointer(&in_p1)) 
	
	
	in_p2 := C.openffi_float32(p2); C.set_arg(paramsBuffer, 1, unsafe.Pointer(&in_p2)) 
	
	
	in_p3 := C.openffi_int8(p3); C.set_arg(paramsBuffer, 2, unsafe.Pointer(&in_p3)) 
	
	
	in_p4 := C.openffi_int16(p4); C.set_arg(paramsBuffer, 3, unsafe.Pointer(&in_p4)) 
	
	
	in_p5 := C.openffi_int32(p5); C.set_arg(paramsBuffer, 4, unsafe.Pointer(&in_p5)) 
	
	
	in_p6 := C.openffi_int64(p6); C.set_arg(paramsBuffer, 5, unsafe.Pointer(&in_p6)) 
	
	
	in_p7 := C.openffi_uint8(p7); C.set_arg(paramsBuffer, 6, unsafe.Pointer(&in_p7)) 
	
	
	in_p8 := C.openffi_uint16(p8); C.set_arg(paramsBuffer, 7, unsafe.Pointer(&in_p8)) 
	
	
	in_p9 := C.openffi_uint32(p9); C.set_arg(paramsBuffer, 8, unsafe.Pointer(&in_p9)) 
	
	
	in_p10 := C.openffi_uint64(p10); C.set_arg(paramsBuffer, 9, unsafe.Pointer(&in_p10)) 
	
	
	var in_p11 C.openffi_bool; if p11 { in_p11 = C.openffi_bool(1) } else { in_p11 = C.openffi_bool(0) }; C.set_arg(paramsBuffer,10, unsafe.Pointer(&in_p11))
	
	
	in_p12 := C.CString(p12); in_p12_len := C.ulong(len(p12)); defer C.free(unsafe.Pointer(in_p12)); C.set_arg(paramsBuffer,11, unsafe.Pointer(in_p12)); C.set_arg(paramsBuffer,12, unsafe.Pointer(&in_p12_len)) 
	
	
	in_p13_arr := make([]C.openffi_string, 0); in_p13_go_sizes := make([]C.openffi_size, 0); in_p13_len := C.openffi_size(len(p13)); for _, val := range p13 { curCval := C.CString(val); in_p13_arr = append(in_p13_arr, curCval); in_p13_go_sizes = append(in_p13_go_sizes, C.openffi_size(len(val)));  defer C.free(unsafe.Pointer(curCval)) }; in_p13 := &(in_p13_arr[0]); in_p13_sizes := &(in_p13_go_sizes[0]); C.set_arg(paramsBuffer,13, unsafe.Pointer(in_p13)); C.set_arg(paramsBuffer,14, unsafe.Pointer(in_p13_sizes)); C.set_arg(paramsBuffer,15, unsafe.Pointer(&in_p13_len)); 
	
	
	in_p14_arr := make([]C.openffi_uint8, 0); in_p14_len := C.openffi_size(len(p14)); for _, val := range p14 { in_p14_arr = append(in_p14_arr, C.openffi_uint8(val)) }; in_p14 := &(in_p14_arr[0]); C.set_arg(paramsBuffer,16,unsafe.Pointer(in_p14)); C.set_arg(paramsBuffer,17,unsafe.Pointer(&in_p14_len));
	
	

	var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)

	C.call(pruntime_plugin, C.uint(len(runtime_plugin)),
			C.int64_t(F1_id),
			paramsBuffer, paramsBufferLength,
			returnValuesBuffer, returnValuesBufferLength,
			&out_err, &out_err_len)

	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	// convert from C to Go
	
	
	out_r1 := (*C.openffi_string)(C.get_arg_pointer_type(returnValuesBuffer, 0)); out_r1_sizes := (*C.openffi_size)(C.get_arg_pointer_type(returnValuesBuffer, 1)); out_r1_len := C.get_arg_openffi_size(returnValuesBuffer, 2); ret_r1 := make([]string, 0); for i:=C.openffi_size(0) ; i<out_r1_len ; i++ { val_size := C.openffi_size(0); val := C.get_openffi_string_element(C.int(i), out_r1, out_r1_sizes, &val_size); ret_r1 = append(ret_r1, C.GoStringN(val, C.int(val_size))) }
	
	
	
	return ret_r1, nil
}



