package main
import "C"

const HostHeaderTemplate = `
// Code generated by OpenFFI. DO NOT EDIT.
// Host code for {{.IDLFilenameWithExtension}}
`

const HostPackageTemplate = `package {{.Package}}
`


const HostImports = `
import "fmt"
import "os"
import "unsafe"
import "github.com/golang/protobuf/proto"
import "runtime"
`

const HostCImport = `
/*
#cgo !windows LDFLAGS: -L. -ldl

#include <stdlib.h>
#include <stdint.h>
void* xllr_handle = NULL;
void (*pcall)(const char*, uint32_t,
			 const char*, uint32_t,
			 const char*, uint32_t,
			 unsigned char*, uint64_t,
			 unsigned char**, uint64_t*,
			 unsigned char**, uint64_t*,
			 uint8_t*) = NULL;

int64_t (*pload_function)(const char*, uint32_t,
						const char*, uint32_t,
						int64_t,
						unsigned char**, uint32_t*)

#ifdef _WIN32 //// --- START WINDOWS ---
#include <Windows.h>
void get_last_error_string(DWORD err, char** out_err_str)
{
    DWORD bufLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
							     FORMAT_MESSAGE_IGNORE_INSERTS,
							     NULL,
							     err,
						         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						         (LPTSTR) out_err_str,
						         0,
						         NULL );

    // TODO: out_err_str should get cleaned up!
}

void* load_library(const char* name, char** out_err)
{
	void* handle = LoadLibraryA(name);
	if(!handle)
	{
		get_last_error_string(GetLastError(), out_err);
	}

	return handle;
}

const char* free_library(void* lib) // return error string. null if no error.
{
	if(!lib)
	{
		return NULL;
	}

	if(!FreeLibrary(lib))
	{
		char* out_err;
		get_last_error_string(GetLastError(), &out_err);
		return out_err;
	}

	return NULL;
}

void* load_symbol(void* handle, const char* name, char** out_err)
{
	void* res = GetProcAddress(handle, name);
	if(!res)
	{
		get_last_error_string(GetLastError(), out_err);
		return NULL;
	}

	return res;
}

#else // ------ START POSIX ----
#include <dlfcn.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = dlopen(name, RTLD_NOW);
	if(!handle)
	{
		*out_err = dlerror();
	}

	return handle;
}

const char* free_library(void* lib)
{
	if(dlclose(lib))
	{
		return dlerror();
	}

	return NULL;
}

void* load_symbol(void* handle, const char* name, char** out_err)
{
	void* res = dlsym(handle, name);
	if(!res)
	{
		*out_err = dlerror();
		return NULL;
	}

	return res;
}

#endif // ------- END POSIX -----

void call(
		const char* runtime_plugin, uint32_t runtime_plugin_len,
		const char* module_name, uint32_t module_name_len,
		const char* func_name, uint32_t func_name_len,
		unsigned char* in_params, uint64_t in_params_len,
		unsigned char** out_params, uint64_t* out_params_len,
		unsigned char** out_ret, uint64_t* out_ret_len,
		uint8_t* is_error
)
{
	pcall(runtime_plugin, runtime_plugin_len,
			module_name, module_name_len,
			func_name, func_name_len,
			in_params, in_params_len,
			out_params, out_params_len,
			out_ret, out_ret_len,
			is_error);
}

const char* load_xllr_api()
{
	char* out_err = NULL;
	pcall = load_symbol(xllr_handle, "call", &out_err);
	if(!pcall)
	{
		return out_err;
	}

	pload_function = load_symbol(xllr_handle, "load_function", &out_err);
	if(!pload_function)
	{
		return out_err;
	}

	return NULL;
}

*/
import "C"
`

const HostHelperFunctions = `
func freeXLLR() error{
	errstr := C.free_library(C.xllr_handle)

	if errstr != nil{
		return fmt.Errorf("Failed to free XLLR: %v", C.GoString(errstr))
	}

	return nil
}

// TODO: make sure it is called only once!
func loadXLLR() error{

	if C.xllr_handle != nil && C.pcall != nil{
        return nil
    }

	openffiHome := os.Getenv("OPENFFI_HOME")
    if openffiHome == ""{
    	return fmt.Errorf("OPENFFI_HOME is not set")
	}

	var name *C.char
	if runtime.GOOS == "darwin" {
		name = C.CString(openffiHome+"/xllr.dylib")
	}else if runtime.GOOS == "windows"{
		name = C.CString(openffiHome+"\\xllr.dll")
	} else {
		name = C.CString(openffiHome+"/xllr.so")
	}

	defer C.free(unsafe.Pointer(name))

	var out_err *C.char
	if C.xllr_handle = C.load_library(name, &out_err)
	C.xllr_handle == nil{ // error has occurred
		return fmt.Errorf("Failed to load XLLR: %v", C.GoString(out_err))
	}

    if cerr := C.load_xllr_api(); cerr != nil{
        return fmt.Errorf("Failed to load call function: %v", C.GoString(cerr))
    }

	return nil
}
`

const HostFunctionStubsTemplate = `
{{ $pfn := .IDLFilename}}
{{range $mindex, $m := .Modules}}

// Code to call foreign functions in module {{$m.Name}} via XLLR
{{range $findex, $f := $m.Functions}}
// Call to foreign {{$f.PathToForeignFunction.function}}
{{if $f.Comment}}/*
{{$f.Comment}}
*/{{end}}
{{range $index, $elem := $f.Parameters}}
{{if $elem.Comment}}// {{$elem.Name}} - {{$elem.Comment}}{{end}}{{end}}
var {{$f.PathToForeignFunction.function}}_id int64 = -1
func {{AsPublic $f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}} {{$elem.Name}} {{if $elem.IsArray}}[]{{end}}{{if $elem.InnerTypes}}*{{end}}{{$elem.Type}}{{if eq $elem.Type "map"}}[{{$elem.MapKeyType}}]{{$elem.MapValueType}}{{end}}{{end}}) ({{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}} {{if $elem.IsArray}}[]{{end}}{{if $elem.InnerTypes}}*{{end}}{{$elem.Type}}{{if eq $elem.Type "map"}}[{{$elem.MapKeyType}}]{{$elem.MapValueType}}{{end}}{{end}}{{if $f.ReturnValues}},{{end}} err error){

	// serialize parameters
	req := {{ToGoNameConv $f.ParametersType}}{}
	{{range $index, $elem := $f.Parameters}}
	req.{{AsPublic $elem.Name}} = {{$elem.Name}}
	{{end}}

	// load XLLR
	err = loadXLLR()
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	// load function (no need to use a lock)
	runtime_plugin := "xllr.{{$m.TargetLanguage}}"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(unsafe.Pointer(pruntime_plugin))

	if {$f.PathToForeignFunction.function}}_id == -1{
		path := "{{$f.PathToForeignFunctionAsString}}"

		var out_err *C.uchar
		var out_err_len C.uint32_t
		out_err_len = C.uint32_t(0)
		{{$f.PathToForeignFunction.function}}_id = C.pload_function(pruntime_plugin, len(runtime_plugin), path, len(path), -1, &out_err, &out_err_len)
		
		if {$f.PathToForeignFunction.function}}_id == -1{ // failed
			return fmt.Errorf("Failed to load function %v: %v", {{$f.PathToForeignFunction.function}}, C.GoString(out_err))
		}
	}
	
	// in parameters
	in_params, err := proto.Marshal(&req)
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	var pin_params *C.uchar
	var in_params_len C.uint64_t
	if len(in_params) > 0{
		pin_params = (*C.uchar)(unsafe.Pointer(&in_params[0]))
		in_params_len = C.uint64_t(len(in_params))
	} else {
		in_params_len = C.uint64_t(0)
	}

	var out_ret *C.uchar
	var out_ret_len C.uint64_t
	out_ret_len = C.uint64_t(0)

	var out_params *C.uchar
	var out_params_len C.uint64_t
	out_params_len = C.uint64_t(0)

	var out_is_error C.uchar
	out_is_error = C.uchar(0)

	C.call(pruntime_plugin, C.uint(len(runtime_plugin)),
			{{$f.PathToForeignFunction.function}}_id,
			pin_params, in_params_len,
			&out_params, &out_params_len,
			&out_ret, &out_ret_len,
			&out_is_error)

	// check errors
	if out_is_error != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_ret), C.int(out_ret_len))))
		return
	}

	// deserialize result	
	ret := {{ToGoNameConv $f.ReturnValuesType}}{}
	out_ret_buf := C.GoBytes(unsafe.Pointer(out_ret), C.int(out_ret_len))
	err = proto.Unmarshal(out_ret_buf, &ret)
	if err != nil{
		err = fmt.Errorf("Failed to unmarshal return values into protobuf. Error: %v", err)
		return
	}

	return {{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}ret.{{AsPublic $elem.Name}}{{end}}{{if $f.ReturnValues}},{{end}} nil

}
{{end}}
{{end}}

`

