package main
import "C"

const HostHeaderTemplate = `
// Code generated by OpenFFI. DO NOT EDIT.
// Host code for {{.IDLFilenameWithExtension}}
`

const HostPackageTemplate = `package {{.Package}}
`


const HostImports = `
import "fmt"
import "unsafe"
import "plugin"
import "os"
import "runtime"
`

const HostCImportTemplate = `
/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I{{GetEnvVar "OPENFFI_HOME"}}

#include <stdlib.h>
#include <stdint.h>
#include <include/cdt_structs.h>
#include <include/cdt_capi_loader.h>
#include <include/cdt_capi_loader.c>

openffi_size get_int_item(openffi_size* array, int index)
{
	return array[index];
}

void* convert_union_to_ptr(void* p)
{
	return p;
}

void set_cdt_type(struct cdt* p, openffi_type t)
{
	p->type = t;
}

openffi_type get_cdt_type(struct cdt* p)
{
	return p->type;
}

void set_go_runtime_flag()
{
	xllr_set_runtime_flag("go_runtime", 10);
}

*/
import "C"
`

const HostHelperFunctions = `
func init(){
	err := C.load_cdt_capi()
	if err != nil{
		panic("Failed to load OpenFFI XLLR functions: "+C.GoString(err))
	}

	C.set_go_runtime_flag();

	loadObjectsTable()
}

var goRuntimeLib *plugin.Plugin
var setObjectTable func(interface{})unsafe.Pointer
var getObjectTable func(unsafe.Pointer) (interface{}, bool)

type handle unsafe.Pointer

func loadObjectsTable(){
	openffiHome := os.Getenv("OPENFFI_HOME")
	if openffiHome == ""{
		panic("Cannot find OPENFFI_HOME environment variable")
	}

	var extension string
	switch runtime.GOOS{
		case "windows": extension = ".dll"
		case "darwin": extension = ".dylib"
		default: extension = ".so"
	}

	var err error
	goRuntimeLib, err = plugin.Open(openffiHome+string(os.PathSeparator)+"xllr.go.runtime"+extension)
	if err != nil{ panic(err) }
	
	setFunc, err := goRuntimeLib.Lookup("Set")
	if err != nil{ panic(err) }

	getFunc, err := goRuntimeLib.Lookup("Get")
	if err != nil{ panic(err) }

	setObjectTable = setFunc.(func(interface{})unsafe.Pointer)
	getObjectTable = getFunc.(func(unsafe.Pointer) (interface{}, bool))

}

func setObject(obj interface{}) handle{
	return handle(setObjectTable(obj))
}

func getObject(h handle) (interface{}, bool){
	return getObjectTable(unsafe.Pointer(h))
}
`

const HostFunctionStubsTemplate = `
{{ $pfn := .IDLFilename}}
{{range $mindex, $m := .Modules}}

// Code to call foreign functions in module {{$m.Name}} via XLLR
{{range $findex, $f := $m.Functions}}
// Call to foreign {{$f.PathToForeignFunction.function}}
{{if $f.Comment}}/*
{{$f.Comment}}
*/{{end}}
{{range $index, $elem := $f.Parameters}}
{{if $elem.Comment}}// {{$elem.Name}} - {{$elem.Comment}}{{end}}{{end}}
var {{$f.PathToForeignFunction.function}}_id int64 = -1
func {{AsPublic $f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}} {{$elem.Name}} {{ConvertToGoType $elem}}{{end}}) ({{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}} {{ConvertToGoType $elem}}{{end}}{{if $f.ReturnValues}},{{end}} err error){

	runtime_plugin := "xllr.{{$m.TargetLanguage}}"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(unsafe.Pointer(pruntime_plugin))

	if {{$f.PathToForeignFunction.function}}_id == -1{

		// load function (no need to use a lock)

		path := "{{$f.PathToForeignFunctionAsString}}"
		ppath := C.CString(path)
		defer C.free(unsafe.Pointer(ppath))

		var out_err *C.char
		var out_err_len C.uint32_t
		out_err_len = C.uint32_t(0)
		{{$f.PathToForeignFunction.function}}_id = int64(C.xllr_load_function(pruntime_plugin, C.uint(len(runtime_plugin)), ppath, C.uint(len(path)), C.int64_t(-1), &out_err, &out_err_len))
		
		if {{$f.PathToForeignFunction.function}}_id == -1{ // failed
			err = fmt.Errorf("Failed to load function %v: %v", "{{$f.PathToForeignFunction.function}}", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
			return
		}
	}

	{{ $paramsLength := len $f.Parameters }}{{ $returnLength := len $f.ReturnValues }}

	parameters := C.alloc_cdts_buffer( {{$paramsLength}} )
	return_values := C.alloc_cdts_buffer( {{$returnLength}} )
	
	// parameters
	{{range $index, $elem := $f.Parameters}}

	{{if $elem.IsAny}}
	// any
	switch {{$elem.Name}}.(type) {
		{{ range $numTypeIndex, $numType := GetNumericTypes }}
		case {{$numType}}:
			in_{{$elem.Name}} := C.openffi_{{$numType}}({{$elem.Name}}.({{$numType}}))
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_{{$numType}}_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_{{$numType}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$numType}})(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_{{$numType}}_{{$elem.Name}}.val = in_{{$elem.Name}}

		{{end}}
		

		{{ range $index, $numType := GetNumericTypes }}
		case []{{$numType}}:
			in_{{$elem.Name}}_dimensions := C.openffi_size(1)
			in_{{$elem.Name}}_dimensions_lengths := (*C.openffi_size)(C.malloc(C.sizeof_openffi_size))
			*in_{{$elem.Name}}_dimensions_lengths = C.ulong(len({{$elem.Name}}.([]{{$numType}})))
		
			in_{{$elem.Name}} := (*C.openffi_{{$numType}})(C.malloc(C.ulong(len({{$elem.Name}}.([]{{$numType}})))*C.sizeof_openffi_{{$numType}}))
			for i, val := range {{$elem.Name}}.([]{{$numType}}){
				C.set_openffi_{{$numType}}_element(in_{{$elem.Name}}, C.int(i), C.openffi_{{$numType}}(val))
			}
		
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_{{$numType}}_array_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_{{$numType}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$numType}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_{{$numType}}_{{$elem.Name}}.vals = in_{{$elem.Name}}
			pcdt_in_{{$numType}}_{{$elem.Name}}.dimensions_lengths = in_{{$elem.Name}}_dimensions_lengths
			pcdt_in_{{$numType}}_{{$elem.Name}}.dimensions = in_{{$elem.Name}}_dimensions

		{{end}}

		case int:
			in_{{$elem.Name}} := C.openffi_int64(int64({{$elem.Name}}.(int)))
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_int64_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_int64_{{$elem.Name}} := ((*C.struct_cdt_openffi_int64)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_int64_{{$elem.Name}}.val = in_{{$elem.Name}}

		case []int:
			in_{{$elem.Name}}_dimensions := C.openffi_size(1)
			in_{{$elem.Name}}_dimensions_lengths := (*C.openffi_size)(C.malloc(C.sizeof_openffi_size))
			*in_{{$elem.Name}}_dimensions_lengths = C.ulong(len({{$elem.Name}}.([]int)))
		
			in_{{$elem.Name}} := (*C.openffi_int64)(C.malloc(C.ulong(len({{$elem.Name}}.([]int)))*C.sizeof_openffi_int64))
			for i, val := range {{$elem.Name}}.([]int){
				C.set_openffi_int64_element(in_{{$elem.Name}}, C.int(i), C.openffi_int64(val))
			}
		
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_int64_array_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_int64_{{$elem.Name}} := ((*C.struct_cdt_openffi_int64_array)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_int64_{{$elem.Name}}.vals = in_{{$elem.Name}}
			pcdt_in_int64_{{$elem.Name}}.dimensions_lengths = in_{{$elem.Name}}_dimensions_lengths
			pcdt_in_int64_{{$elem.Name}}.dimensions = in_{{$elem.Name}}_dimensions

		case bool:
			var in_{{$elem.Name}} C.openffi_bool
			if {{$elem.Name}}.(bool) { in_{{$elem.Name}} = C.openffi_bool(1) } else { in_{{$elem.Name}} = C.openffi_bool(0) }
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_bool_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_bool_{{$elem.Name}} := ((*C.struct_cdt_openffi_bool)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_bool_{{$elem.Name}}.val = in_{{$elem.Name}}

		case string:
			in_{{$elem.Name}}_len := C.openffi_size(C.ulong(len({{$elem.Name}}.(string))))
			in_{{$elem.Name}} := C.CString({{$elem.Name}}.(string))
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_string8_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_string8_{{$elem.Name}} := ((*C.struct_cdt_openffi_string8)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_string8_{{$elem.Name}}.val = in_{{$elem.Name}}
			pcdt_in_string8_{{$elem.Name}}.length = in_{{$elem.Name}}_len

		case []bool:
			in_{{$elem.Name}}_dimensions := C.openffi_size(1)
			in_{{$elem.Name}}_dimensions_lengths := (*C.openffi_size)(C.malloc(C.sizeof_openffi_size))
			*in_{{$elem.Name}}_dimensions_lengths = C.openffi_size(len({{$elem.Name}}.([]bool)))
		
			in_{{$elem.Name}} := (*C.openffi_bool)(C.malloc(C.openffi_size(len({{$elem.Name}}.([]bool)))*C.sizeof_openffi_bool))
			for i, val := range {{$elem.Name}}.([]bool){
				var bval C.openffi_bool
				if val { bval = C.openffi_bool(1) } else { bval = C.openffi_bool(0) }
				C.set_openffi_bool_element(in_{{$elem.Name}}, C.int(i), C.openffi_bool(bval))
			}
		
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_bool_array_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_bool_{{$elem.Name}} := ((*C.struct_cdt_openffi_bool_array)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_bool_{{$elem.Name}}.vals = in_{{$elem.Name}}
			pcdt_in_bool_{{$elem.Name}}.dimensions_lengths = in_{{$elem.Name}}_dimensions_lengths
			pcdt_in_bool_{{$elem.Name}}.dimensions = in_{{$elem.Name}}_dimensions

		case []string:
			in_{{$elem.Name}} := (*C.openffi_string8)(C.malloc(C.ulong(len({{$elem.Name}}.([]string)))*C.sizeof_openffi_string8))
			in_{{$elem.Name}}_sizes := (*C.openffi_size)(C.malloc(C.ulong(len({{$elem.Name}}.([]string)))*C.sizeof_openffi_size))
			in_{{$elem.Name}}_dimensions := C.openffi_size(1)
			in_{{$elem.Name}}_dimensions_lengths := (*C.openffi_size)(C.malloc(C.sizeof_openffi_size * (in_{{$elem.Name}}_dimensions)))
			*in_{{$elem.Name}}_dimensions_lengths = C.openffi_size(len({{$elem.Name}}.([]string)))
			
			for i, val := range {{$elem.Name}}.([]string){
				C.set_openffi_string8_element(in_{{$elem.Name}}, in_{{$elem.Name}}_sizes, C.int(i), C.openffi_string8(C.CString(val)), C.openffi_size(len(val)))
			}
			
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_string8_array_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_string8_{{$elem.Name}} := ((*C.struct_cdt_openffi_string8_array)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_string8_{{$elem.Name}}.vals = in_{{$elem.Name}}
			pcdt_in_string8_{{$elem.Name}}.vals_sizes = in_{{$elem.Name}}_sizes
			pcdt_in_string8_{{$elem.Name}}.dimensions_lengths = in_{{$elem.Name}}_dimensions_lengths
			pcdt_in_string8_{{$elem.Name}}.dimensions = in_{{$elem.Name}}_dimensions
			
		default:
			// Turn object to a handle
			{{$elem.Name}}_handle := setObject({{$elem.Name}})
			
			in_{{$elem.Name}} := C.openffi_handle({{$elem.Name}}_handle)
			in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
			C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_handle_type)
			in_{{$elem.Name}}_cdt.free_required = 1
			pcdt_in_handle_{{$elem.Name}} := ((*C.struct_cdt_openffi_handle)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
			pcdt_in_handle_{{$elem.Name}}.val = in_{{$elem.Name}}
	}

	
	{{else if $elem.IsString}}
	{{if gt $elem.Dimensions 0}}
	// string array

	in_{{$elem.Name}} := (*C.openffi_{{$elem.Type}})(C.malloc(C.ulong(len({{$elem.Name}}))*{{Sizeof $elem}}))
	in_{{$elem.Name}}_sizes := (*C.openffi_size)(C.malloc(C.ulong(len({{$elem.Name}}))*C.sizeof_openffi_size))
	in_{{$elem.Name}}_dimensions := C.openffi_size(1)
	in_{{$elem.Name}}_dimensions_lengths := (*C.openffi_size)(C.malloc(C.sizeof_openffi_size * (in_{{$elem.Name}}_dimensions)))
	*in_{{$elem.Name}}_dimensions_lengths = C.openffi_size(len({{$elem.Name}}))
	
	for i, val := range {{$elem.Name}}{
		C.set_openffi_{{$elem.Type}}_element(in_{{$elem.Name}}, in_{{$elem.Name}}_sizes, C.int(i), C.openffi_{{$elem.Type}}(C.CString(val)), C.openffi_size(len(val)))
	}
	
	in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
	C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_{{$elem.Type}}_array_type)
	in_{{$elem.Name}}_cdt.free_required = 1
	pcdt_in_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.vals = in_{{$elem.Name}}
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.vals_sizes = in_{{$elem.Name}}_sizes
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.dimensions_lengths = in_{{$elem.Name}}_dimensions_lengths
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.dimensions = in_{{$elem.Name}}_dimensions

	{{else}}
	// string
	in_{{$elem.Name}}_len := C.openffi_size(C.ulong(len({{$elem.Name}})))
	in_{{$elem.Name}} := C.CString({{$elem.Name}})
	
	in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
	C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_{{$elem.Type}}_type)
	in_{{$elem.Name}}_cdt.free_required = 1
	pcdt_in_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}})(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.val = in_{{$elem.Name}}
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.length = in_{{$elem.Name}}_len

	{{end}}{{else}}{{if gt $elem.Dimensions 0}}
	// non-string array
	
	in_{{$elem.Name}}_dimensions := C.openffi_size(1)
	in_{{$elem.Name}}_dimensions_lengths := (*C.openffi_size)(C.malloc(C.sizeof_openffi_size))
	*in_{{$elem.Name}}_dimensions_lengths = C.openffi_size(len({{$elem.Name}}))

	in_{{$elem.Name}} := (*C.openffi_{{$elem.Type}})(C.malloc(C.openffi_size(len({{$elem.Name}}))*{{Sizeof $elem}}))
	for i, val := range {{$elem.Name}}{
		{{if $elem.IsBool}}
		var bval C.openffi_bool
		if val { bval = C.openffi_bool(1) } else { bval = C.openffi_bool(0) }
		C.set_openffi_bool_element(in_{{$elem.Name}}, C.int(i), C.openffi_bool(bval))
		{{else}}
		C.set_openffi_{{$elem.Type}}_element(in_{{$elem.Name}}, C.int(i), C.openffi_{{$elem.Type}}(val))
		{{end}}
	}

	in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
	C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_{{$elem.Type}}_array_type)
	in_{{$elem.Name}}_cdt.free_required = 1
	pcdt_in_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.vals = in_{{$elem.Name}}
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.dimensions_lengths = in_{{$elem.Name}}_dimensions_lengths
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.dimensions = in_{{$elem.Name}}_dimensions

	{{else}}
	// non-string
	
	{{if $elem.IsBool}}
	var in_{{$elem.Name}} C.openffi_bool
	if {{$elem.Name}} { 
		in_{{$elem.Name}} = C.openffi_bool(1)
	} else { 
		in_{{$elem.Name}} = C.openffi_bool(0)
	}
	{{else}}
	in_{{$elem.Name}} := C.openffi_{{$elem.Type}}({{$elem.Name}})
	{{end}}
	in_{{$elem.Name}}_cdt := C.get_cdt(parameters, {{$index}})
	C.set_cdt_type(in_{{$elem.Name}}_cdt, C.openffi_{{$elem.Type}}_type)
	in_{{$elem.Name}}_cdt.free_required = 1
	pcdt_in_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}})(C.convert_union_to_ptr(unsafe.Pointer(&in_{{$elem.Name}}_cdt.cdt_val))))
	pcdt_in_{{$elem.Type}}_{{$elem.Name}}.val = in_{{$elem.Name}}
	{{end}}
	{{end}}
	{{end}}	

	var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)

	C.xllr_call(pruntime_plugin, C.uint(len(runtime_plugin)),
			C.int64_t({{$f.PathToForeignFunction.function}}_id),
			parameters, {{$paramsLength}},
			return_values, {{$returnLength}},
			&out_err, &out_err_len)

	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	{{range $index, $elem := $f.ReturnValues}}

	{{if $elem.IsAny}}
	// any
	var ret_{{$elem.Name}} interface{}
	out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
	{{$elem.Name}}_type := C.get_cdt_type(out_{{$elem.Name}}_cdt)
	switch {{$elem.Name}}_type{

		case {{GetOpenFFIType "handle"}}: // handle
			pcdt_out_handle_{{$elem.Name}} := ((*C.struct_cdt_openffi_handle)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}} C.openffi_handle = pcdt_out_handle_{{$elem.Name}}.val			

			var found bool
			ret_{{$elem.Name}}, found = getObject(handle(out_{{$elem.Name}}))
			if !found{ // handle belongs to 
				ret_{{$elem.Name}} = handle(out_{{$elem.Name}})
			}

		case {{GetOpenFFIArrayType "handle"}}: // []handle
			pcdt_out_handle_{{$elem.Name}} := ((*C.struct_cdt_openffi_handle_array)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}} *C.openffi_handle = pcdt_out_handle_{{$elem.Name}}.vals
			var out_{{$elem.Name}}_dimensions_lengths *C.openffi_size = pcdt_out_handle_{{$elem.Name}}.dimensions_lengths
			// var out_{{$elem.Name}}_dimensions C.openffi_size = pcdt_out_handle_{{$elem.Name}}.dimensions - TODO: not used until multi-dimensions support!

			ret_{{$elem.Name}}_typed := make([]interface{}, 0)
			for i:=C.int(0) ; i<C.int(C.int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0))) ; i++{
				val := C.get_openffi_handle_element(out_{{$elem.Name}}, C.int(i))

				var found bool
				val_obj, found := getObject(handle(val))
				if !found{ // handle belongs to 
					val_obj = val
				}
				
				ret_{{$elem.Name}}_typed = append(ret_{{$elem.Name}}_typed, val_obj)
			}
			ret_{{$elem.Name}} = ret_{{$elem.Name}}_typed

		{{range $numTypeEnumIndex, $numType := GetNumericTypes}}{{if ne $numType "handle"}}
		case {{GetOpenFFIType $numType}}: // {{$numType}}
			pcdt_out_{{$numType}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$numType}})(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}} C.openffi_{{$numType}} = pcdt_out_{{$numType}}_{{$elem.Name}}.val
			
			ret_{{$elem.Name}} = {{$numType}}(out_{{$elem.Name}})

		{{end}}{{end}}

		{{range $numTypeEnumIndex, $numType := GetNumericTypes}}{{if ne $numType "handle"}}
		case {{GetOpenFFIArrayType $numType}}: // []{{$numType}}
			pcdt_out_{{$numType}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$numType}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}} *C.openffi_{{$numType}} = pcdt_out_{{$numType}}_{{$elem.Name}}.vals
			var out_{{$elem.Name}}_dimensions_lengths *C.openffi_size = pcdt_out_{{$numType}}_{{$elem.Name}}.dimensions_lengths
			// var out_{{$elem.Name}}_dimensions C.openffi_size = pcdt_out_{{$numType}}_{{$elem.Name}}.dimensions - TODO: not used until multi-dimensions support!
					
			ret_{{$elem.Name}}_typed := make([]{{$numType}}, 0)
			for i:=C.int(0) ; i<C.int(C.int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0))) ; i++{
				val := C.get_openffi_{{$numType}}_element(out_{{$elem.Name}}, C.int(i))
				ret_{{$elem.Name}}_typed = append(ret_{{$elem.Name}}_typed, {{$numType}}(val))
			}
			ret_{{$elem.Name}} = ret_{{$elem.Name}}_typed
		{{end}}{{end}}

		{{range $numTypeEnumIndex, $stringType := GetOpenFFIStringTypes}}
		case {{GetOpenFFIType $stringType}}: // {{$stringType}}
			out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
			pcdt_out_{{$stringType}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$stringType}})(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}}_len C.openffi_size = pcdt_out_{{$stringType}}_{{$elem.Name}}.length
			var out_{{$elem.Name}} C.openffi_{{$stringType}} = pcdt_out_{{$stringType}}_{{$elem.Name}}.val
		
			ret_{{$elem.Name}} = C.GoStringN(out_{{$elem.Name}}, C.int(out_{{$elem.Name}}_len))
		{{end}}

		{{range $numTypeEnumIndex, $stringType := GetOpenFFIStringTypes}}
		case {{GetOpenFFIArrayType $stringType}}: // []{{$stringType}}
			out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
			pcdt_out_{{$stringType}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$stringType}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
		
			var out_{{$elem.Name}} *C.openffi_{{$stringType}} = pcdt_out_{{$stringType}}_{{$elem.Name}}.vals
			var out_{{$elem.Name}}_sizes *C.openffi_size = pcdt_out_{{$stringType}}_{{$elem.Name}}.vals_sizes
			var out_{{$elem.Name}}_dimensions_lengths *C.openffi_size = pcdt_out_{{$stringType}}_{{$elem.Name}}.dimensions_lengths
			//var out_{{$elem.Name}}_dimensions C.openffi_size = pcdt_out_{{$stringType}}_{{$elem.Name}}.dimensions - TODO: not used until multi-dimensions support!
		
			ret_{{$elem.Name}}_typed := make([]string, 0, int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0)))
			for i:=C.int(0) ; i<C.int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0)) ; i++{
				var str_size C.openffi_size
				str := C.get_openffi_{{$stringType}}_element(out_{{$elem.Name}}, C.int(i), out_{{$elem.Name}}_sizes, &str_size)
				ret_{{$elem.Name}}_typed = append(ret_{{$elem.Name}}_typed, C.GoStringN(str, C.int(str_size)))
			}
			ret_{{$elem.Name}} = ret_{{$elem.Name}}_typed
		{{end}}


		case {{GetOpenFFIType "bool"}}: // bool
			out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
			pcdt_out_bool_{{$elem.Name}} := ((*C.struct_cdt_openffi_bool)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}} C.openffi_bool = pcdt_out_bool_{{$elem.Name}}.val
			
			ret_{{$elem.Name}} = out_{{$elem.Name}} != C.openffi_bool(0)

		case {{GetOpenFFIArrayType "bool"}}: // []bool
			out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
			pcdt_out_bool_{{$elem.Name}} := ((*C.struct_cdt_openffi_bool_array)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
			var out_{{$elem.Name}} *C.openffi_bool = pcdt_out_bool_{{$elem.Name}}.vals
			var out_{{$elem.Name}}_dimensions_lengths *C.openffi_size = pcdt_out_bool_{{$elem.Name}}.dimensions_lengths
			// var out_{{$elem.Name}}_dimensions C.openffi_size = pcdt_out_bool_{{$elem.Name}}.dimensions - TODO: not used until multi-dimensions support!
					
			ret_{{$elem.Name}}_typed := make([]bool, 0)
			for i:=C.int(0) ; i<C.int(C.int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0))) ; i++{
				val := C.get_openffi_bool_element(out_{{$elem.Name}}, C.int(i))
				var bval bool
				if val != 0 { bval = true } else { bval = false }
				ret_{{$elem.Name}}_typed = append(ret_{{$elem.Name}}_typed, bval)
			}

			ret_{{$elem.Name}} = ret_{{$elem.Name}}_typed

		default:
			err = fmt.Errorf("Return value %v is not of a supported type, but of type: %v", "{{$elem.Name}}", {{$elem.Name}}_type)
			return
	}

	{{else if $elem.IsString}}	
	{{if gt $elem.Dimensions 0}}
	// string[] // TODO: handle multi-dimensional arrays
	out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
	pcdt_out_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))

	var out_{{$elem.Name}} *C.openffi_{{$elem.Type}} = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.vals
	var out_{{$elem.Name}}_sizes *C.openffi_size = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.vals_sizes
	var out_{{$elem.Name}}_dimensions_lengths *C.openffi_size = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.dimensions_lengths
	//var out_{{$elem.Name}}_dimensions C.openffi_size = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.dimensions - TODO: not used until multi-dimensions support!

	ret_{{$elem.Name}} := make([]string, 0, int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0)))
	for i:=C.int(0) ; i<C.int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0)) ; i++{
		var str_size C.openffi_size
		str := C.get_openffi_{{$elem.Type}}_element(out_{{$elem.Name}}, C.int(i), out_{{$elem.Name}}_sizes, &str_size)
		ret_{{$elem.Name}} = append(ret_{{$elem.Name}}, C.GoStringN(str, C.int(str_size)))
	}

	{{else}}

	// string
	out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
	pcdt_out_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}})(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
	var out_{{$elem.Name}}_len C.openffi_size = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.length
	var out_{{$elem.Name}} C.openffi_{{$elem.Type}} = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.val

	ret_{{$elem.Name}} := C.GoStringN(out_{{$elem.Name}}, C.int(out_{{$elem.Name}}_len))
	{{end}}{{else}}{{if $elem.IsArray}}

	// non-string array
	out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
	pcdt_out_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}}_array)(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
	var out_{{$elem.Name}} *C.openffi_{{$elem.Type}} = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.vals
	var out_{{$elem.Name}}_dimensions_lengths *C.openffi_size = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.dimensions_lengths
	// var out_{{$elem.Name}}_dimensions C.openffi_size = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.dimensions - TODO: not used until multi-dimensions support!
			
	ret_{{$elem.Name}} := make([]{{$elem.Type}}, 0)
	for i:=C.int(0) ; i<C.int(C.int(C.get_int_item(out_{{$elem.Name}}_dimensions_lengths, 0))) ; i++{
		val := C.get_openffi_{{$elem.Type}}_element(out_{{$elem.Name}}, C.int(i))
		ret_{{$elem.Name}} = append(ret_{{$elem.Name}}, {{$elem.Type}}(val))
	}
	{{else}}

	// non-string
	out_{{$elem.Name}}_cdt := C.get_cdt(return_values, {{$index}})
	pcdt_out_{{$elem.Type}}_{{$elem.Name}} := ((*C.struct_cdt_openffi_{{$elem.Type}})(C.convert_union_to_ptr(unsafe.Pointer(&out_{{$elem.Name}}_cdt.cdt_val))))
	var out_{{$elem.Name}} C.openffi_{{$elem.Type}} = pcdt_out_{{$elem.Type}}_{{$elem.Name}}.val
	
	ret_{{$elem.Name}} := {{if eq $elem.Type "bool"}}out_{{$elem.Name}} != C.openffi_bool(0){{else}}{{$elem.Type}}(out_{{$elem.Name}}){{end}}
	{{end}}
	{{end}}
	{{end}}

	return {{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}ret_{{$elem.Name}}{{end}}{{if gt $returnLength 0}},{{end}} nil
}
{{end}}
{{end}}

`

