package main

const GuestHeaderTemplate = `
// Code generated by OpenFFI. Modify only in marked places.
// Guest code for {{.IDLFilenameWithExtension}}

package main
`

const GuestImportsTemplate = `
import "github.com/golang/protobuf/proto"
import "fmt"
{{range $mindex, $i := .Imports}}
import . "{{$i}}"{{end}}

`

const GuestCImport = `
/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I{{.ENV.OPENFFI_HOME}}

#include <stdint.h>
#include <stdarg.h>
#include <openffi_primitives.h>
*/
import "C"
`

const GuestMainFunction = `
func main(){} // main function must be declared to create dynamic library
`

const GuestHelperFunctions = `
func errToOutError(out_err **C.char, out_err_len *C.uint64_t, customText string, err error){
	*is_error = 1
	txt := customText
	if err != nil { txt += err.Error() }
	*out_err = C.CString(txt)
	*out_err_len = C.uint64_t(len(txt))
}

func panicHandler(out_err **C.char, out_err_len *C.uint64_t, is_error *C.uint8_t){
	
	if rec := recover(); rec != nil{
		msg := "Panic in Go function. Panic Data: "
		switch recType := rec.(type){
			case error: msg += (rec.(error)).Error()
			case string: msg += rec.(string)
			default: msg += fmt.Sprintf("Panic with type: %v - %v", recType, rec)
		}

		*is_error = 1
		*out_err = C.CString(msg)
		*out_err_len = C.uint64_t(len(msg))
	}
}
`

const GuestFunctionXLLRTemplate = `
// add functions
{{range $mindex, $m := .Modules}}

{{range $findex, $f := $m.Functions}}

// Call to foreign {{$f.PathToForeignFunction.function}}
//export EntryPoint_{{$f.PathToForeignFunction.function}}
func EntryPoint_{{$f.PathToForeignFunction.function}}(out_err **C.char, out_err_len *C.uint64_t, args_size C.uint64_t, params C.va_list){

	// catch panics and return them as errors
	defer panicHandler(out_ret, out_ret_len, is_error)
	
	*out_err_len = 0

	isFailed := C.uint8(0);

	// parameters
	{{range $index, $elem := $f.Parameters}}C.set_openffi_param(openffi_{{$elem.Type}}, in_{{$elem.Name}}, params, args_size, isFailed){{end}}
	if isFailed != C.uint8(0){
		errToOutError(out_err, out_err_len, "Too many arguments were read from va_list while reading parameters in EntryPoint_{{$f.PathToForeignFunction.function}}", nil)
		return
	}
	
	// return values
	{{range $index, $elem := $f.ReturnValues}}C.set_openffi_param(*openffi_{{$elem.Type}}, out_{{$elem.Name}}, params, args_size, isFailed){{end}}
	if isFailed != C.uint8(0){
		errToOutError(out_err, out_err_len, "Too many arguments were read from va_list while reading return values in EntryPoint_{{$f.PathToForeignFunction.function}}", nil)
		return
	}

	if args_size > C.uint64(0){
		errToOutError(out_err, out_err_len, "Not all arguments were read from va_list in EntryPoint_{{$f.PathToForeignFunction.function}}", nil)
		return
	}

	// convert parameters from C to Go
	{{range $index, $elem := $f.Parameters}}
	{{ConvertToGo in_$elem.Name $elem}}
	{{end}}

	// call original function
	{{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}ret_{{$elem.Name}}{{end}}{{if $f.ReturnValues}} := {{end}}{{$f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}}{{$elem.Name}}{{end}})

	// return values
	{{range $index, $elem := $f.ReturnValues}}
	if err, isError := interface{}({{$elem.Name}}).(error); isError{ // in case of error
		errToOutError(out_err, out_err_len, is_error, "Error returned", err)
		return
	} else { // Convert from Go to C
		*out_{{$elem.Name}} = {{ConvertToC $elem in_$elem.Name}}
	}	
	{{end}}	
}
{{end}}{{end}}

`
