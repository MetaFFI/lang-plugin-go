package main

const GuestHeaderTemplate = `
// Code generated by OpenFFI. Modify only in marked places.
// Guest code for {{.IDLFilenameWithExtension}}

package main
`

const GuestImportsTemplate = `
import "fmt"
{{range $mindex, $i := .Imports}}
import . "{{$i}}"{{end}}

`

const GuestCImportTemplate = `
/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I{{GetEnvVar "OPENFFI_HOME"}}

#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <openffi_primitives.h>
*/
import "C"
`

const GuestMainFunction = `
func main(){} // main function must be declared to create dynamic library
`

const GuestHelperFunctions = `
func errToOutError(out_err **C.char, out_err_len *C.uint64_t, customText string, err error){
	txt := customText
	if err != nil { txt += err.Error() }
	*out_err = C.CString(txt)
	*out_err_len = C.uint64_t(len(txt))
}

func panicHandler(out_err **C.char, out_err_len *C.uint64_t){
	
	if rec := recover(); rec != nil{
		msg := "Panic in Go function. Panic Data: "
		switch recType := rec.(type){
			case error: msg += (rec.(error)).Error()
			case string: msg += rec.(string)
			default: msg += fmt.Sprintf("Panic with type: %v - %v", recType, rec)
		}

		*out_err = C.CString(msg)
		*out_err_len = C.uint64_t(len(msg))
	}
}
`

const GuestFunctionXLLRTemplate = `
// add functions
{{range $mindex, $m := .Modules}}

{{range $findex, $f := $m.Functions}}

// Call to foreign {{$f.PathToForeignFunction.function}}
//export EntryPoint_{{$f.PathToForeignFunction.function}}
func EntryPoint_{{$f.PathToForeignFunction.function}}(parameters **C.void, parameters_length C.uint64_t, return_values **C.void, return_values_length C.uint64_t, out_err **C.char, out_err_len *C.uint64_t){

	// catch panics and return them as errors
	defer panicHandler(out_err, out_err_len)
	*out_err_len = 0

	// parameters from C to Go
	bufIndex := C.int(0)
	{{range $index, $elem := $f.Parameters}}
	{{if $elem.IsString}}
	{{if $elem.IsArray}}
	in_{{$elem.Name}} := (*C.openffi_{{$elem.Type}})(C.get_arg_pointer_type(parameters, bufIndex))
	in_{{$elem.Name}}_sizes := (*C.openffi_size)(C.get_arg_pointer_type(parameters, bufIndex+1))
	in_{{$elem.Name}}_len := (C.openffi_size)(C.get_arg_openffi_size(parameters, bufIndex+2))
	bufIndex += C.openffi_size({{CalculateArgLength $elem}})

	{{$elem.Name}} := make([]{{$elem.Type}}, 0)
	for i:=0 ; i<in{{$elem.Name}} ; i++{
		str_size := C.openffi_size(0)
		str := C.get_openffi_string_element(i, in_{{$elem.Name}}, in_{{$elem.Name}}_sizes, &str_size)
		{{$elem.Name}} = append({{$elem.Name}}, C.GoStringN(str, str_size))
	}
	{{else}}
	in_{{$elem.Name}} := (C.openffi_{{$elem.Type}})(C.get_arg_pointer_type(parameters, bufIndex))
	in_{{$elem.Name}}_len := (C.openffi_size)(C.get_arg_openffi_size(parameters, bufIndex+1))
	{{$elem.Name}} := C.GoStringN(in_{{$elem.Name}}, in_{{$elem.Name}}_len)
	bufIndex += C.openffi_size({{CalculateArgLength $elem}})
	{{end}}
	{{else}}
	
	{{if $elem.IsArray}}
	in_{{$elem.Name}} := *C.openffi_{{$elem.Type}}(C.get_arg_pointer_type(parameters, bufIndex))
	in_{{$elem.Name}}_len := C.get_va_arg_openffi_size(params, bufIndex+1)
	
	{{$elem.Name}} := make([]{{$elem.Type}}, 0)
	for i:=0 ; i<in{{$elem.Name}} ; i++{
		str_size := C.openffi_size(0)
		str := C.get_openffi_string_element(i, in_{{$elem.Name}}, in_{{$elem.Name}}_sizes, &str_size)
		{{$elem.Name}} = append({{$elem.Name}}, C.GoStringN(str, str_size))
	}
	{{else}}
	in_{{$elem.Name}} = C.get_va_arg_openffi_{{$elem.Type}}(params, &args_size, &isFailed){{end}}
	
	if isFailed == 0{
		errToOutError(out_err, out_err_len, "Too many arguments were read from va_list while reading parameters in EntryPoint_{{$f.PathToForeignFunction.function}}", nil)
		return
	}
	{{end}}
	
	// return values
	{{range $index, $elem := $f.ReturnValues}}
	out_{{$elem.Name}} := {{if $elem.IsArray}}*{{end}}*C.openffi_{{$elem.Type}}(C.get_va_arg_pointer_type(params, &args_size, &isFailed))
	{{if $elem.IsString}}
	{{if $elem.IsArray}}out_{{$elem.Name}}_sizes := **C.openffi_size(C.get_va_arg_pointer_type(params, &args_size, &isFailed)){{end}}
	out_{{$elem.Name}}_len := *C.openffi_size(C.get_va_arg_pointer_type(params, &args_size, &isFailed))
	{{else if $elem.IsArray}}
	out_{{$elem.Name}}_len := *C.openffi_size(C.get_va_arg_pointer_type(params, &args_size, &isFailed))
	{{end}}
	if isFailed == 0{
		errToOutError(out_err, out_err_len, "Too many arguments were read from va_list while reading parameters in EntryPoint_{{$f.PathToForeignFunction.function}}", nil)
		return
	}
	{{end}}

	// convert parameters from C to Go
	{{range $index, $elem := $f.Parameters}}
	{{ConvertToGo $elem "in" ""}}
	{{end}}

	// call original function
	{{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}}{{end}}{{if $f.ReturnValues}} := {{end}}{{$f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}}{{$elem.Name}}{{end}})

	// return values
	{{range $index, $elem := $f.ReturnValues}}
	if err, isError := interface{}({{$elem.Name}}).(error); isError{ // in case of error
		errToOutError(out_err, out_err_len, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		{{ConvertToCGuest $elem "out"}}
	}	
	{{end}}	
}
{{end}}{{end}}

`
