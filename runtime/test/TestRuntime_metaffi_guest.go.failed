
// Code generated by MetaFFI. Modify only in marked places.
// Guest code for TestRuntime.go

package main

import "fmt"
import "unsafe"
import "reflect"
import "runtime"
import "github.com/MetaFFI/sdk/idl_entities/go/IDL"
import . "github.com/MetaFFI/sdk/api/go/metaffi"

import . "TestRuntime"





/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I"C:/src/github.com/MetaFFI/output/windows/x64/debug"

#include <include/cdt.h>
#include <include/xllr_capi_loader.h>

metaffi_size get_int_item(metaffi_size* array, int index);
void* convert_union_to_ptr(void* p);
void set_cdt_type(struct cdt* p, metaffi_type t);
metaffi_type get_cdt_type(struct cdt* p);

struct cdt* get_cdt_element(struct cdts* pdata, int cdts_index);
metaffi_handle get_null_handle();

#ifdef _WIN32
	metaffi_size len_to_metaffi_size(long long i);
#else
	metaffi_size len_to_metaffi_size(long long i);
#endif
*/
import "C"


var dummyreflect reflect.Type




// getter for FiveSeconds
//export EntryPoint_GetFiveSeconds 
func EntryPoint_GetFiveSeconds(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){

	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	retvals_CDTS := C.get_cdt_element(xcall_params, 0)
	t0 := IDL.MetaFFITypeInfo{ 
	    StringType: "any",
	    Alias:"any",
	    Dimensions: 0,
		Type: 4194304,
	}
	FromGoToCDT(FiveSeconds, unsafe.Pointer(retvals_CDTS), t0, 0)

}
 

 

 


// functions

// Call to foreign HelloWorld
//export EntryPoint_HelloWorld
func EntryPoint_HelloWorld(_ *C.void, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	

	// parameters from C to Go
	 
	
	// call original function
	
	HelloWorld()

	
	
	// return values
	 
}

// Call to foreign ReturnsAnError
//export EntryPoint_ReturnsAnError
func EntryPoint_ReturnsAnError(_ *C.void, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	

	// parameters from C to Go
	 
	
	// call original function
	
	ReturnsAnError()

	
	
	// return values
	 
}

// Call to foreign DivIntegers
//export EntryPoint_DivIntegers
func EntryPoint_DivIntegers(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 1)
	

	// parameters from C to Go
	
	xAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	x := int(xAsInterface.(int64))
	
	yAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 1, nil)
	y := int(yAsInterface.(int64))
	 
	
	// call original function
	
	ret := DivIntegers(x,y)

	
	
	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "float32",
			Alias:"float32",
			Dimensions: 0,
			Type: 2,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}

// Call to foreign JoinStrings
//export EntryPoint_JoinStrings
func EntryPoint_JoinStrings(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 1)
	

	// parameters from C to Go
	
	arrsAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	arrs := arrsAsInterface.([]string)

	 
	
	// call original function
	
	ret := JoinStrings(arrs)

	
	
	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "string8",
			Alias:"string",
			Dimensions: 0,
			Type: 4096,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}

// Call to foreign WaitABit
//export EntryPoint_WaitABit
func EntryPoint_WaitABit(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	

	// parameters from C to Go
	
	dAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	d := dAsInterface.(time.Duration)
	 
	
	// call original function
	
	errReturn_ := WaitABit(d)

	
	if errReturn_ != nil {
		errToOutError(out_err, "Error returned: ", errReturn_)
		return
	}
	
	
	// return values
	 
}

// Call to foreign GetSomeClasses
//export EntryPoint_GetSomeClasses
func EntryPoint_GetSomeClasses(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 0)
	

	// parameters from C to Go
	 
	
	// call original function
	
	ret := GetSomeClasses()

	
	
	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "handle",
			Alias:"[]SomeClass",
			Dimensions: 1,
			Type: 32768,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}

// Call to foreign ExpectThreeSomeClasses
//export EntryPoint_ExpectThreeSomeClasses
func EntryPoint_ExpectThreeSomeClasses(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	

	// parameters from C to Go
	
	arrAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	arr := arrAsInterface.([]SomeClass)

	 
	
	// call original function
	
	ExpectThreeSomeClasses(arr)

	
	
	// return values
	 
}

// Call to foreign ExpectThreeBuffers
//export EntryPoint_ExpectThreeBuffers
func EntryPoint_ExpectThreeBuffers(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	

	// parameters from C to Go
	
	buffersAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	buffers := buffersAsInterface.([][]byte)

	 
	
	// call original function
	
	ExpectThreeBuffers(buffers)

	
	
	// return values
	 
}

// Call to foreign GetThreeBuffers
//export EntryPoint_GetThreeBuffers
func EntryPoint_GetThreeBuffers(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 0)
	

	// parameters from C to Go
	 
	
	// call original function
	
	ret := GetThreeBuffers()

	
	
	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "uint8",
			Alias:"[][]byte",
			Dimensions: 2,
			Type: 64,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}

// Call to foreign NewTestMap
//export EntryPoint_NewTestMap
func EntryPoint_NewTestMap(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 0)
	

	// parameters from C to Go
	 
	
	// call original function
	
	ret := NewTestMap()

	
	
	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "handle",
			Alias:"*TestMap",
			Dimensions: 0,
			Type: 32768,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}
 



// class SomeClass




// return empty struct
//export EntryPoint_SomeClass_EmptyStruct_MetaFFI
func EntryPoint_SomeClass_EmptyStruct_MetaFFI(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	instance := &SomeClass{}
	FromGoToCDT(instance, unsafe.Pointer(C.get_cdt_element(xcall_params, 0)), IDL.MetaFFITypeInfo{ StringType: IDL.HANDLE, Dimensions: 0, Type: 32768 }, 0)
}


// constructors
 

// methods

// Call to foreign Print
//export EntryPoint_SomeClass_Print
func EntryPoint_SomeClass_Print(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	
	
	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	

	// parameters from C to Go
		
	this_instanceAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	this_instance := this_instanceAsInterface.(interface{})
	 
	
	// call original function (method receiver must be first parameter; IDL adds this_instance for methods)
	
	
	
	(this_instance.(SomeClass)).Print()
	

	

	// return values
	 
}
 

// Fields
 

// end class SomeClass

// class TestMap




// return empty struct
//export EntryPoint_TestMap_EmptyStruct_MetaFFI
func EntryPoint_TestMap_EmptyStruct_MetaFFI(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	instance := &TestMap{}
	FromGoToCDT(instance, unsafe.Pointer(C.get_cdt_element(xcall_params, 0)), IDL.MetaFFITypeInfo{ StringType: IDL.HANDLE, Dimensions: 0, Type: 32768 }, 0)
}


// constructors

// Call to foreign NewTestMap
//export EntryPoint_TestMap_NewTestMap
func EntryPoint_TestMap_NewTestMap(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	
	
	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 0)
	

	// parameters from C to Go
	 
	
	// call original function
	
	ret := NewTestMap()

	
	
	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{ 
			StringType: "handle",
			Alias:"*TestMap",
			Dimensions: 0,
			Type: 32768,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}
 

// methods

// Call to foreign Set
//export EntryPoint_TestMap_Set
func EntryPoint_TestMap_Set(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	
	
	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	

	// parameters from C to Go
		
	this_instanceAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	this_instance := this_instanceAsInterface.(interface{})
		
	kAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 1, nil)
	k := kAsInterface.(string)
		
	vAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 2, nil)
	v := vAsInterface
	 
	
	// call original function (method receiver must be first parameter; IDL adds this_instance for methods)
	
	
	
	(this_instance.(*TestMap)).Set(k,v)
	

	

	// return values
	 
}

// Call to foreign Get
//export EntryPoint_TestMap_Get
func EntryPoint_TestMap_Get(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	
	
	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 1)
	

	// parameters from C to Go
		
	this_instanceAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	this_instance := this_instanceAsInterface.(interface{})
		
	kAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 1, nil)
	k := kAsInterface.(string)
	 
	
	// call original function (method receiver must be first parameter; IDL adds this_instance for methods)
	
	
	
	ret := (this_instance.(*TestMap)).Get(k)
	

	

	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "any",
			Alias:"interface{}",
			Dimensions: 0,
			Type: 4194304,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}

// Call to foreign Contains
//export EntryPoint_TestMap_Contains
func EntryPoint_TestMap_Contains(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){
	// catch panics and return them as errors
	defer panicHandler(out_err)

	
	
	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 1)
	

	// parameters from C to Go
		
	this_instanceAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	this_instance := this_instanceAsInterface.(interface{})
		
	kAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 1, nil)
	k := kAsInterface.(string)
	 
	
	// call original function (method receiver must be first parameter; IDL adds this_instance for methods)
	
	
	
	ret := (this_instance.(*TestMap)).Contains(k)
	

	

	// return values
	
	if err, isError := interface{}(ret).(error); isError{ // in case of error
		errToOutError(out_err, "Error returned", err)
		return
	} else { // Convert return values from Go to C
		t0 := IDL.MetaFFITypeInfo{   
			StringType: "bool",
			Alias:"bool",
			Dimensions: 0,
			Type: 1024,
		}
		FromGoToCDT(ret, unsafe.Pointer(retvals_CDTS), t0, 0)
	}	
	 
}
 

// Fields


// getter for Name
//export EntryPoint_TestMap_GetName
func EntryPoint_TestMap_GetName(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){

	// catch panics and return them as errors
	defer panicHandler(out_err)
	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	
	retvals_CDTS := C.get_cdt_element(xcall_params, 1)
	

	// get object
	
	objAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	obj := interface{}(objAsInterface.(interface{}))

	
	Name_res := obj.(TestMap).Name

	
	t0 := IDL.MetaFFITypeInfo{ 
		StringType: "string8",
		Alias:"string",
		Dimensions: 0,
		Type: 4096,
	}
	FromGoToCDT(Name_res, unsafe.Pointer(retvals_CDTS), t0, 0)
	
}
 


// setter for Name
//export EntryPoint_TestMap_SetName
func EntryPoint_TestMap_SetName(_ *C.void, xcall_params *C.struct_cdts, out_err **C.char){

	// catch panics and return them as errors
	defer panicHandler(out_err)

	

	
	parameters_CDTS := C.get_cdt_element(xcall_params, 0)
	
	

	// get object
	
	thisAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 0, nil)
	this := interface{}(thisAsInterface.(interface{}))

	// get val
	
	NameAsInterface := FromCDTToGo(unsafe.Pointer(parameters_CDTS), 1, nil)
	Name := NameAsInterface.(string)
	
	// set new data (always use pointer assertion for setters - value assertions are non-addressable in Go)
	this.(*TestMap).Name = Name
	
}


 

// end class TestMap
 

 



func errToOutError(out_err **C.char, customText string, err error){
	txt := customText
	if err != nil { txt += err.Error() }
	goCString := C.CString(txt)
	defer C.free(unsafe.Pointer(goCString))
	*out_err = C.xllr_alloc_string(goCString, C.uint64_t(len(txt)))
}

func panicHandler(out_err **C.char){
	if rec := recover(); rec != nil{
		msg := "Panic in Go function. Panic Data: "
		switch recType := rec.(type){
		case error:
			msg += (rec.(error)).Error()
		case string:
			msg += rec.(string)
		default:
			msg += fmt.Sprintf("Panic with type: %v - %v", recType, rec)
		}

		// Add stack trace to message
		stack := make([]byte, 1024*8)
		stack = stack[:runtime.Stack(stack, false)]
		msg = fmt.Sprintf("%s\nStack Trace:\n%s", msg, string(stack))

		goCString := C.CString(msg)
		defer C.free(unsafe.Pointer(goCString))
		*out_err = C.xllr_alloc_string(goCString, C.uint64_t(len(msg)))
	}
}


func main(){} // main function must be declared to create dynamic library
func init(){
	err := C.load_xllr()
	if err != nil{
		panic("Failed to load MetaFFI XLLR functions: "+C.GoString(err))
	}

}
